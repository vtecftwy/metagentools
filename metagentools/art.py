# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs-dev/02_art.ipynb.

# %% auto 0
__all__ = ['ArtIllumina']

# %% ../nbs-dev/02_art.ipynb 2
# Imports all dependencies
import os
import subprocess
import shlex
import sys

from pathlib import Path
from typing import Tuple, List, Optional

# %% ../nbs-dev/02_art.ipynb 8
def _run(args: List[str], shell: bool=False):
    """Wrapper subprocess.run and prints the output"""
    p = subprocess.run(args=args, stdout=subprocess.PIPE, shell=shell)
    print('return code: ',p.returncode, '\n')
    print(str(p.stdout, 'utf-8'))

# %% ../nbs-dev/02_art.ipynb 9
def _validate_path(p:str|Path) -> Path:
    """checks that path is a string or a Path, and returns a Path"""
    if isinstance(p, str): 
        p = Path(p)
    elif not isinstance(p, Path): 
        raise TypeError(f"a path must be a string or a Path, not a {type(p)}")
    return p

# %% ../nbs-dev/02_art.ipynb 10
class ArtIllumina:
    """Simulate sequence reads with art_illumina"""

    def __init__(
        self, 
        path2app: str|Path,           # path to the art_illumina application on the system
        input_dir: str|Path,          # path to the dir where input files are
        output_dir: str|Path=None     # path to the dir where to save output files, if different from input_dir
        ):
        """Initialize the art_illumina instance"""

        # Validate and save paths
        path2app = _validate_path(path2app)        
        if path2app.is_file():
            self.app = path2app
        else:
            raise ValueError(f"{path2app.name} is not a file, please check the path to the application")

        input_dir = _validate_path(input_dir)
        if input_dir.is_dir():
            self.input_dir = input_dir
        else:
            raise ValueError(f"{input_dir.name} is not a directory, please check the path")

        if output_dir is None: 
            self.output_dir = input_dir
        else:
            output_dir = _validate_path(output_dir)
            if output_dir.is_dir():
                self.output_dir = output_dir
            else:
                raise ValueError(f"{input_dir.name} is not a directory, please check the path")

        print(f"Ready to operate with art: {self.app.absolute()}")
        print(f"Input files from : {self.input_dir.absolute()}")
        print(f"Output files to :  {self.output_dir.absolute()}")

    def sim_reads(
        self,
        input_file: str,     # name of the fasta file to use as input
        output_seed: str,    # seed to use for the output files
        sim_type='paired',   # type of read simmulation: 'single' or 'paired'
        read_length=150,     # length of the read in bp
        fold=10,             # fold
        mean_read=None,      # mean length of the read for paired reads
        std_read=None,       # std of the read length, for paired reads
        ss='HS25',           # quality profile to use for simulation
        ):
        """Simulates reads with art_illumina"""
        
        self.last_input_file = self.input_dir / input_file
        p2in = (self.last_input_file).absolute()
        self.last_ouput_seed = output_seed
        p2out = (self.output_dir / output_seed).absolute()

        if sim_type == 'single':
            params = f"-ss {ss} -sam -l {read_length} -f {fold}"
        elif sim_type == 'paired':
            if mean_read is None or std_read is None:
                raise ValueError(f"mean_read and std_read are required for a paired reads simulation")
            else:
                params = f"-ss {ss} -sam -p -l {read_length} -f {fold} -m {mean_read} -s {std_read}"
        else:
            raise RuntimeError(f"{sim_type} in not a type or is not implemented yet")

        cmd = f"{self.app.absolute()} -i {p2in} {params} -o {p2out}"

        _run(args=shlex.split(cmd))
